---
title: "(s)PLS(-DA) on combined regions"
output:
  html_document:
    keep_md: true   
---

```{r setup-chunk, include=FALSE}
knitr::opts_chunk$set(dev = "png",
                      dpi = 900,
                      echo = FALSE,
                      cache = TRUE)
```

# Import Libraries
```{r}
library(NanoStringNCTools)
library(GeomxTools)
library(scuttle)

library(SpatialExperiment)
library(standR)
library(pls)

library(dplyr)
library(tidyverse)

library(ggplot2)
library(ggalluvial)
library(ggrepel)

#library(pls)
library(mixOmics)
```

#Load Data
```{r}
datadir <- "data/"
DCCFiles <- dir(datadir, pattern=".dcc$", full.names=TRUE)
PKCFiles <- unzip(zipfile = file.path(datadir,  "/Mm_R_NGS_WTA_v1.0.zip"))
SampleAnnotationFile <- file.path(datadir, "ModifiedWorksheet2.xlsx")

dataSet <-
  readNanoStringGeoMxSet(dccFiles = DCCFiles,
                                          pkcFiles = PKCFiles,
                                          phenoDataFile = SampleAnnotationFile,
                                          phenoDataSheet = "Sheet1",
                                          phenoDataDccColName = "Sample_ID",
                                          protocolDataColNames = c("Roi",
                                                                   "Aoi"))

dataSet <- dataSet[,pData(dataSet)$SlideName != "No Template Control"] #remove no template control

flimParams <- read_csv("matlab scripts/roiSummaryTable2.csv")
```

## Normalize data
```{r}
#make spatial experiment object
dataSet_target <- aggregateCounts(dataSet)
dataSet_targetQnorm <- normalize(dataSet_target, norm_method = "quant")
seDataSetQnorm <- as.SpatialExperiment(dataSet_targetQnorm, normData = "exprs_norm")
seDataSet <- as.SpatialExperiment(dataSet_target, normData = "exprs" ,forceRaw = TRUE)


assay(seDataSet, "counts") <- assay(seDataSet, "GeoMx")
assay(seDataSet, "logcounts") <- log2(assay(seDataSet, "GeoMx") + 1)
assay(seDataSetQnorm, "counts") <- assay(seDataSetQnorm, "GeoMx")
assay(seDataSetQnorm, "logcounts") <- log2(assay(seDataSetQnorm, "GeoMx"))

plotRLExpr(seDataSet, ordannots = "Segment", color = Segment, assay = 3) + ggtitle("Raw Counts") #logcounts
plotRLExpr(seDataSetQnorm, ordannots = "Segment", color = Segment, assay = 3) + ggtitle("Quantile Normalized (nanostring method)") #logcounts
seDataSet_tmm <- geomxNorm(seDataSet, method = "TMM")
plotRLExpr(seDataSet_tmm, ordannots = "Segment", color = Segment, assay = 3) + ggtitle("TMM Normalized")#logcounts
#tmm does better than nanostring method by RLE metric

tmmSubset <- seDataSet_tmm[, seDataSet_tmm$Segment == "PanCK+"]

#create object with counts summed across same segment types within samples
summedRaw <- aggregateAcrossCells(seDataSet, as.factor(paste(colData(seDataSet)$sample,colData(seDataSet)$Segment)), statistics = "sum")
assay(summedRaw, "logcounts") <- log2(assay(summedRaw) + 1)
summedRaw_tmm <- geomxNorm(summedRaw, method = "TMM")

plotRLExpr(summedRaw, color = factor(sample), assay = "logcounts") + ggtitle("Raw")
plotRLExpr(summedRaw_tmm, color = factor(sample), assay = "logcounts") + ggtitle("TMM Normalized")

summedRaw_tmmPCKP <- summedRaw_tmm[, summedRaw_tmm$Segment == "PanCK+"]
```

#Do sPLS with FLIm features on summed data
```{r}
summedCountsMatrixPCKP <- t(assay(summedRaw_tmmPCKP, 'logcounts'))

colMatrxPCKP <- as.data.frame(colData(summedRaw_tmmPCKP))
joined <- left_join(colMatrxPCKP, flimParams, by = "sample")

seletedFlimParams <- subset(joined, select = c(LT2mean, LT3mean))
splsResult <- spls(summedCountsMatrixPCKP, seletedFlimParams, mode = "regression", scale = TRUE, ncomp = 2, keepX = 50, keepY = 2)
```

#Analysis on sPLS result
```{r}
splsResult$prop_expl_var

variableImportance <- as.data.frame(vip(splsResult)) %>% arrange(desc(comp1))
head(variableImportance, n = 50)
#write.csv(variableImportance, "sPLS_FLIm_VIP.csv")

#plotIndiv(splsResult, group=joined$Group, legend = TRUE)
#plotLoadings(splsResult, method = 'mean', contrib = 'max')
```

#Do sPLS-DA on treatment group with summed data
```{r}
splsdaResult <- splsda(summedCountsMatrixPCKP, as.factor(joined$Group), keepX = 50, scale = TRUE, ncomp=2)

splsdaResult$prop_expl_var
#plotIndiv(splsdaResult)
#plotVar(splsdaResult)
selectVar(splsdaResult, comp = 1)$name

plotLoadings(splsdaResult, method = 'mean', contrib = 'max')  

variableImportanceGroup <- as.data.frame(vip(splsdaResult)) %>% arrange(desc(comp1))
head(variableImportanceGroup, n = 50)
#write.csv(variableImportanceGroup, "sPLS_Group_VIP.csv")
```

#Do sPLS-DA on sex group with summed data
```{r}
splsdaResultSex <- splsda(summedCountsMatrixPCKP, as.factor(joined$Sex.x), keepX = 50, scale = TRUE)

splsdaResultSex$prop_expl_var
plotIndiv(splsdaResultSex)
#plotVar(splsdaResultSex)
selectVar(splsdaResultSex, comp = 1)$name

plotLoadings(splsdaResultSex, method = 'mean', contrib = 'max')  

variableImportanceGroup <- as.data.frame(vip(splsdaResultSex)) %>% arrange(desc(comp1))
head(variableImportanceGroup, n = 500)
```

```{r}
plotGeneWrtFlimFeature <- function(seObject, flimParamsTable, geneName, colName, yLabel) {
  geneCounts <- (assay(seObject, 'logcounts')[geneName,])
  colMatrix <- as.data.frame(colData(summedRaw_tmmPCKP))
  joined <- left_join(colMatrxPCKP, flimParamsTable, by = "sample")
  flimFeature <- joined[colName]
  
  toPlot <- cbind(flimFeature, geneCounts, subset(joined, select = c(sample, Group, Sex.x)))
  
  flimCol <- ensym(colName)
  ggplot(toPlot, aes(x=geneCounts, y=!!ensym(colName), color=Group, shape=Sex.x)) + geom_point() + theme_bw() +
    xlab("Log Counts") + 
    ylab(yLabel) + 
    ggtitle(geneName) +
    labs(shape = "Sex")
}

plotGeneWrtFlimFeature(summedRaw_tmmPCKP, flimParams, "Endog", "LT2mean", "Channel 2 Lifetime (ns)")
plotGeneWrtFlimFeature(summedRaw_tmmPCKP, flimParams, "Clip1", "LT2mean", "Channel 2 Lifetime (ns)")
plotGeneWrtFlimFeature(summedRaw_tmmPCKP, flimParams, "Tnnc2", "LT2mean", "Channel 2 Lifetime (ns)")
plotGeneWrtFlimFeature(summedRaw_tmmPCKP, flimParams, "Odf3b", "LT2mean", "Channel 2 Lifetime (ns)")
plotGeneWrtFlimFeature(summedRaw_tmmPCKP, flimParams, "Nscme3l", "LT2mean", "Channel 2 Lifetime (ns)")
```
```{r}
ggplotRegression <- function (fit) { #from https://sejohnston.com/2012/08/09/a-quick-and-easy-function-to-plot-lm-results-in-r/

require(ggplot2)

ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) + 
  geom_point() +
  stat_smooth(method = "lm", col = "red") +
  labs(title = paste("Adj R2 = ",signif(summary(fit)$adj.r.squared, 5),
                     "Intercept =",signif(fit$coef[[1]],5 ),
                     " Slope =",signif(fit$coef[[2]], 5),
                     " P =",signif(summary(fit)$coef[2,4], 5))) +
  theme_bw()
}

getCorrSquared <- function(seObject, flimParamsTable, geneName, colName, method, doPlot=FALSE) {
  geneCounts <- (assay(seObject, 'logcounts')[geneName,])
  colMatrix <- as.data.frame(colData(summedRaw_tmmPCKP))
  joined <- left_join(colMatrxPCKP, flimParamsTable, by = "sample")
  flimFeature <- joined[colName]
  
  toPlot <- cbind(flimFeature, geneCounts, subset(joined, select = c(sample, Group, Sex.x)))

  #browser()
  
  if (doPlot) {
    browser()
    ggplotRegression(lm(as.formula(paste(colName, "~ geneCounts")), toPlot))
  }
  return(summary(lm(as.formula(paste(colName, "~ geneCounts")), toPlot))$adj.r.squared)
  #return(summary(lm(as.formula(paste(colName, "~ geneCounts")), toPlot))$r.squared)
  
  #return(cor(toPlot$geneCounts, toPlot$LT2mean, method = method)^2)
}

getResidualError <- function(seObject, flimParamsTable, geneName, colName, method) {
  geneCounts <- (assay(seObject, 'logcounts')[geneName,])
  colMatrix <- as.data.frame(colData(summedRaw_tmmPCKP))
  joined <- left_join(colMatrxPCKP, flimParamsTable, by = "sample")
  flimFeature <- joined[colName]
  
  toPlot <- cbind(flimFeature, geneCounts, subset(joined, select = c(sample, Group, Sex.x)))

  #browser()
  return(sigma(lm(as.formula(paste(colName, "~ geneCounts")), toPlot)))
}

variableImportanceLT <- as.data.frame(vip(splsResult)) %>% arrange(desc(comp1))
head(variableImportanceLT, n = 50)

numToPlot = 100;
corPlotMatrix <- data.frame(seq(1:numToPlot+1))
colnames(corPlotMatrix) <- "rank"
corPlotMatrix$name <- lapply(corPlotMatrix$rank, function(curRank) rownames(variableImportanceLT)[curRank])
corPlotMatrix$cor <- as.numeric(lapply(corPlotMatrix$rank, function(curRank) getCorrSquared(summedRaw_tmmPCKP, flimParams, rownames(variableImportanceLT)[curRank], "LT2mean", "pearson")))
corPlotMatrix$sigma <- as.numeric(lapply(corPlotMatrix$rank, function(curRank) getResidualError(summedRaw_tmmPCKP, flimParams, rownames(variableImportanceLT)[curRank], "LT2mean", "pearson")))

ggplot(corPlotMatrix, aes(x=rank, y=cor)) + geom_point() + theme_bw() + xlab("Gene VIP Rank") + ylab(bquote("Adjusted R"^2)) + ggtitle("Correlation Between Channel 2 Lifetime and Log Gene Count \n vs. Variable Importance in Projection Ranking") + theme(plot.title = element_text(hjust = 0.5))

ggplot(corPlotMatrix, aes(x=rank, y=sigma)) + geom_point() + theme_bw() + xlab("Gene VIP Rank") + ylab("Residual Standard Deviation") + ggtitle("Residual Standard Error of Fit Between Channel 2 Lifetime and Log Gene Count \n vs. Variable Importance in Projection Ranking") + theme(plot.title = element_text(hjust = 0.5))
```
#PCA on flim 
http://www.sthda.com/english/articles/31-principal-component-methods-in-r-practical-guide/118-principal-component-analysis-in-r-prcomp-vs-princomp/
```{r}
colMatrx <- as.data.frame(colData(summedRaw_tmmPCKP))

joined <- left_join(colMatrx, flimParams, by = "sample")

res.pca <- prcomp(~ LT2mean + LT3mean + I2mean + I3mean + IR13mean + IR23mean + LT1mean + I1mean, data = joined, scale = TRUE)
fviz_pca_biplot(res.pca, col.ind = joined$Group, repel = TRUE)

# Helper function 
#::::::::::::::::::::::::::::::::::::::::
var_coord_func <- function(loadings, comp.sdev){
  loadings*comp.sdev
}
# Compute Coordinates
#::::::::::::::::::::::::::::::::::::::::
loadings <- res.pca$rotation
sdev <- res.pca$sdev
var.coord <- t(apply(loadings, 1, var_coord_func, sdev)) 
head(var.coord[, 1:4])

# Compute Cos2
#::::::::::::::::::::::::::::::::::::::::
var.cos2 <- var.coord^2
head(var.cos2[, 1:4])

# Compute contributions
#::::::::::::::::::::::::::::::::::::::::
comp.cos2 <- apply(var.cos2, 2, sum)
contrib <- function(var.cos2, comp.cos2){var.cos2*100/comp.cos2}
var.contrib <- t(apply(var.cos2,1, contrib, comp.cos2))
head(var.contrib[, 1:4], num=8)
```

#PLS-DA between FLIm and group
```{r}
selectedParams <- subset(flimParams, select=c('LT1mean', 'LT2mean', 'LT3mean', 'I1mean', 'I2mean', 'I3mean', 'IR13mean', 'IR23mean'))
plsdaResultFlimGroup <- plsda(selectedParams, flimParams$Group)

plsdaResultFlimGroup$prop_expl_var

plotIndiv(plsdaResultFlimGroup, ellipse=TRUE, legend=TRUE)
plotVar(plsdaResultFlimGroup)
variableImportanceFlimGroup <- as.data.frame(vip(plsdaResultFlimGroup)) %>% arrange(desc(comp1))
head(variableImportanceFlimGroup)

# depict weight assigned to each of these variables
plotLoadings(plsdaResultFlimGroup, comp = 1,method = 'mean', contrib = 'max')  
```


